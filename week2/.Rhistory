install.packages('rgdal')
install.packages('raster')
library(rgdal)
library(raster)
install.packages('caret')
library(caret)
quit()
ls
ls()
quit()
library('GISTools')
install.packages('GISTools')
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL)
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL)
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='source')
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='binary')
install.packages("~/Downloads/GISTools_0.7-1-3.tar", repos = NULL)
install.packages("~/Downloads/GISTools_0.7-1-3.tar", repos = NULL,type='binary')
library('GISTools')
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='source')
install.packages("~/Downloads/GISTools_0.7.tar", repos = NULL,type='source')
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL)
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='source')
Rversion
rversion
R.version
install.packages('GISTools')
R.version
install.packages('GISTools')
R.version
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL)
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='binary')
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='source')
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL)
install.packages("~/Downloads/GISTools_0.7-1.tar", repos = NULL,type='source')
library('GISTools')
q()
install.packages("tidyverse")
library(tidyverse)
data()
data()
view(mpg)
names(mpg)
summary(mpg)
view(mpg)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg)
+
geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy))
ggplot(mpg,aes(dipl,hwy))+
geom_point()
ggplot(mpg,aes(dipl,hwy))+
geom_point()
ggplot(mpg,aes(displ,hwy))+
geom_point()
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')
ggplot(data = mpg, mapping = aes(x = displ, y = hwy))+
geom_point()
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')
ggplot(mpg,aes(displ,hwy))+
geom_point(size=1,color='red')
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')+
labs(title='mpg plot')
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')+
labs(title='mpg plot')+
theme_bw()
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')+
labs(title='mpg plot')+
theme_bw(base_size = 11)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='red')+
labs(title='mpg plot')+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(title='mpg plot')+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(title='MPG plot')+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(title='MPG plot',theme(plot.title = element_text(hjust = 0.5)))+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtile('MPG plot',theme(plot.title = element_text(hjust = 0.5)))+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot',theme(plot.title = element_text(hjust = 0.5)))+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')
theme_bw(base_size = 20,plot.title = element_text(hjust = 0.5))
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')+
theme_bw(base_size = 20,plot.title = element_text(hjust = 0.5))
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')+
theme(base_size = 20,plot.title = element_text(hjust = 0.5))
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')+
theme(plot.title = element_text(hjust = 0.5))
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')+
theme(plot.title = element_text(hjust = 0.5))+
theme_bw()
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')+
theme_bw(plot.title = element_text(hjust = 0.5))
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
ggtitle('MPG plot')+
theme_bw()
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency')
ggtitle('MPG plot')+
theme_bw()
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency')
ggtitle('MPG plot')+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency')
title('MPG plot')+
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency',title='MPG Plot')
theme_bw(base_size = 20)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency',title='MPG Plot')
theme_bw(base_size = 30)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency',title='MPG Plot')+
theme_bw(base_size = 30)
ggplot(mpg,aes(displ,hwy))+
geom_point(size=3,color='blue')+
labs(x='Engine Size',y='Fuel efficiency',title='MPG Plot')+
theme_bw(base_size = 20)
library(rspatial)
install.packages('rspatial')
remotes::install_github('rspatial/rspatial')
library(rspatial)
p<-sp_data('preciipitation.csv')
cts<-sp_data('counties.rds')
p<-sp_data('precipitation.csv')
p
head(p)
plot(cts)
points(p[,c('LONG','LAT')])
class(p)
class(cts)
p$pan<-rowSums(p[,6:17])
plot(p$pan)
m<-lm(pan~ALT,data=p)
summary(m)
library(sf)
pt <- st_point(c(0,1))
plot(pt)
pol <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))))
plot(pol)
pol <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,2), c(0,1), c(0,0))))
plot(pol)
pol <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,2), c(0,1), c(0,0.5))))
pol <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,2), c(0,0.5), c(0,0))))
plot(pol)
typeof(pol)
class(pol)
class(point)
class(pt)
typeof(pt)
library(sf)
# Define longitude and latitude
lon <- 0  # Example longitude (for Greenwich, UK)
lat <- 51.5  # Example latitude (for Greenwich, UK)
# Create a point feature
point <- st_point(c(lon, lat))  # Create the point
# Convert to a simple feature object
point_sf <- st_sf(geometry = st_sfc(point))
# Print the point feature
print(point_sf)
# If you want the point to be in a specific Coordinate Reference System (CRS), you can set it using:
point_sf <- st_set_crs(point_sf, 4326)  # 4326 is the EPSG code for WGS 84
library(mapview)
mapview(point_sf)
point
print(point_sf)
plot(cars)
install.packages('plotly')
install.packages('ggplot2')
setwd("~/work")
setwd("~/work/Geog4254-5254G/lab5")
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(terra)
library(mapview)
list.files
list.files()
tifs<-list.files('.',pattern='*.tif$')
landsat<-stack(tifs)
tifs
tifs<-list.files('.',pattern='*.tif$')
landsat <- rast(tifs)
plot(landsat)
tifs<-list.files('.',pattern='*.tif$')
landsat <- rast(tifs)
plot(landsat)
list.files('.')
training_poly<-st_read('trainingsamples.shp')
mapview(landsat)
training_poly<-st_read('trainingsamples.shp')
plot(landsat)
plad(training_poly,add=T)
training_poly<-st_read('trainingsamples.shp')
plot(landsat)
plat(training_poly,add=T)
training_poly<-st_read('trainingsamples.shp')
plot(landsat)
plot(training_poly,add=T)
plot(st_geometry(training_poly),add=T)
plot(landsat)
plot(st_geometry(training_poly),add=T)
st_crs(training_poly)
crs(landsat)
training_poly<-st_read('trainingsamples.shp')
map <- mapview(landsat) + mapview(training_poly, color = "red")
library(raster)
training_poly<-st_read('trainingsamples.shp')
landsat_raster <- stack(tifs)
map <- mapview(landsat_raster) + mapview(training_poly, color = "red")
training_poly<-st_read('trainingsamples.shp')
mapview(training_poly, color = "red")
# Let's assume we are using a single band for simplicity, e.g., the first band
landsat_band <- landsat[[1]]
# Classify or threshold the raster to create a binary raster
# Here we use an arbitrary threshold value, you should adjust this based on your data
threshold_value <- 0.2
binary_raster <- landsat_band > threshold_value
# Convert the binary raster to polygons
polygons <- as.polygons(binary_raster, dissolve = TRUE)
# Simplify the polygons if needed (optional)
# Here we use a tolerance value for simplification, adjust based on your needs
simplified_polygons <- simplifyGeom(polygons, tolerance = 0.01)
# Convert to sf object for better handling and visualization
polygons_sf <- st_as_sf(simplified_polygons)
# Plot the results
plot(st_geometry(polygons_sf), col = 'red', add = TRUE)
# Let's assume we are using a single band for simplicity, e.g., the first band
landsat_band <- landsat[[1]]
# Classify or threshold the raster to create a binary raster
# Here we use an arbitrary threshold value, you should adjust this based on your data
threshold_value <- 0.2
binary_raster <- landsat_band > threshold_value
# Convert the binary raster to polygons
polygons <- as.polygons(binary_raster, dissolve = TRUE)
# Simplify the polygons if needed (optional)
# Here we use a tolerance value for simplification, adjust based on your needs
simplified_polygons <- simplifyGeom(polygons, tolerance = 0.01)
# Convert to sf object for better handling and visualization
polygons_sf <- st_as_sf(simplified_polygons)
# Plot the results
plot(st_geometry(polygons_sf), col = 'red')
st_write(polygons_sf,'imageboundary.shp')
plot(polygons_sf)
a<-mapview(polygons_sf)+mapview(training_poly)
mapview(a)
a
list.files()
training_poly<-st_read('trainingsamples.shp')
#load the landsat image boundary file to see the overlay
imageboundary<-st_read('imageboundary.shp')
mapview(training_poly)+mapview(training_poly)
training_poly<-st_read('trainingsamples.shp')
#load the landsat image boundary file to see the overlay
imageboundary<-st_read('imageboundary.shp')
mapview(imageboundary)+mapview(training_poly)
t_raster <- rasterize(training_poly, landsat, field = "classid")
# Plot the rasterized output
plot(t_raster)
alldata<-addLayer(landsat,t_raster)
# Add the rasterized layer to the Landsat raster
alldata <- c(landsat, t_raster)
#Check dimension of alldata:
dim(alldata)
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, training_poly, method = "simple", df = TRUE)
# Merge the extracted values with the class ID
training_data <- merge(extracted_values, training_poly, by = "ID")
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, training_poly, method = "simple", df = TRUE)
# Merge the extracted values with the class ID
training_data <- merge(extracted_values, training_poly, by = "classid")
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, training_poly, method = "simple", df = TRUE)
head(extracted_values)
training_poly$classid
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, t_raster, method = "simple", df = TRUE)
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, training_poly, method = "simple", df = TRUE)
unique(extracted_values$ID)
training_poly$Classname
head(training_poly)
# Generate unique IDs for each polygon if not already present
training_poly$ID <- 1:nrow(training_poly)
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, training_poly, method = "simple", df = TRUE)
# Assuming the field name in the training polygons is 'classid'
training_data <- merge(extracted_values, as.data.frame(training_poly)[, c("ID", "classid")], by = "ID")
head(training_data)
# Generate unique IDs for each polygon if not already present
training_poly$ID <- 1:nrow(training_poly)
# Extract pixel values from the Landsat raster based on the training polygons
extracted_values <- extract(landsat, training_poly, method = "simple", df = TRUE)
# Assuming the land cover field name in the training polygons is 'classid'
training_data <- merge(extracted_values, as.data.frame(training_poly)[, c("ID", "classid")], by = "ID")
##remove the "ID" column so you only have landsat pixel values and class labels
training_data <- training_data[, -which(names(training_data) == "ID")]
head(training_data)
install.packages('randomForest')
rftree <- randomForest(as.factor(classid) ~. , data = training_data)
library(randomForest)
rftree <- randomForest(as.factor(classid) ~. , data = training_data)
landsat_df <- as.data.frame(landsat, xy = TRUE, na.rm = TRUE)
landsat_df <- as.data.frame(landsat, xy = TRUE)
landsat_df
head(landsat_Df)
head(landsat_df)
landsat_df <- as.data.frame(landsat, xy = TRUE)
# Remove the xy coordinates for prediction
landsat_values <- landsat_df[, -c(1, 2)]
# Make predictions using the random forest model
predictions <- predict(rftree, newdata = landsat_values)
landsat_df <- as.data.frame(landsat, xy = TRUE)
# Remove the xy coordinates for prediction
landsat_values <- landsat_df[, -c(1, 2)]
# Make predictions using the random forest model
predictions <- predict(rftree, newdata = landsat_values)
# Create an empty raster to store predictions
prediction_raster <- rast(landsat)
# Fill the raster with predictions
prediction_raster[] <- NA
prediction_raster[cellFromXY(prediction_raster, landsat_df[, c("x", "y")])] <- as.numeric(landsat_df$prediction)
length(predictions)
temp<-rast('b2.tif')
output <- setValues(temp, predictions)
plot(output)
temp<-rast('b2.tif')
# Fill the raster with predictions
output <- setValues(temp, predictions)
temp<-rast('b2.tif')
# Fill the raster with predictions
output <- setValues(temp, predictions)
plot(output)
writeRaster(output, "random_forest_predictions.tif", format = "GTiff", overwrite = TRUE)
writeRaster(output, "random_forest_predictions.tif", overwrite = TRUE)
setwd("~/work/Geog4254-5254G/lab6")
lc1992 <- rast('loudoun1992.tif')
library(terra)
# Load the land cover maps
lc1992 <- rast('loudoun1992.tif')
lc2001 <- rast('loudoun2001.tif')
# Define the codes for forest and urban in your land cover maps
forest_code <- 1  # Code for forest
urban_code <- 2   # Code for urban
# Identify forest-to-urban change (1) and stable forest (0)
# Create an empty raster with the same dimensions as the input rasters
change_layer <- rast(lc1992)
values(change_layer) <- NA
# Code forest-to-urban change locations as 1
forest_to_urban <- (lc1992 == forest_code) & (lc2001 == urban_code)
values(change_layer)[which(values(forest_to_urban))] <- 1
# Code stable forest locations as 0
stable_forest <- (lc1992 == forest_code) & (lc2001 == forest_code)
values(change_layer)[which(values(stable_forest))] <- 0
# Save the dependent variable raster layer
writeRaster(change_layer, "forest_to_urban_change.tif", format = "GTiff", overwrite = TRUE)
library(terra)
# Load the land cover maps
lc1992 <- rast('loudoun1992.tif')
lc2001 <- rast('loudoun2001.tif')
# Define the codes for forest and urban in your land cover maps
forest_code <- 1  # Code for forest
urban_code <- 2   # Code for urban
# Identify forest-to-urban change (1) and stable forest (0)
# Create an empty raster with the same dimensions as the input rasters
change_layer <- rast(lc1992)
values(change_layer) <- NA
# Code forest-to-urban change locations as 1
forest_to_urban <- (lc1992 == forest_code) & (lc2001 == urban_code)
values(change_layer)[which(values(forest_to_urban))] <- 1
# Code stable forest locations as 0
stable_forest <- (lc1992 == forest_code) & (lc2001 == forest_code)
values(change_layer)[which(values(stable_forest))] <- 0
# Save the dependent variable raster layer
writeRaster(change_layer, "forest_to_urban_change.tif", overwrite = TRUE)
# Plot the result
plot(change_layer, main = "Forest to Urban Change and Stable Forest")
class(stable_forest)
unique(stable_forest)
setwd("~/work/Geog4254-5254G/week1")
knitr::opts_chunk$set(echo = FALSE)
x <- 1
x <- 3
x <- 1
y <- 3
print(x+y)
x <- c(1,2,5.3,6,-2,4)                                                   # numeric
y <- c('VT','CNRE','Geography')                                # character vector
# numeric
x <- c(1,2,5.3,6,-2,4)
# character vector
y <- c('VT','CNRE','Geography')
#Refer to elements of a vector using subscripts.
print(y[2])
# numeric
x <- c(1,2,5.3,6,-2,4)
# character vector
y <- c('VT','CNRE','Geography')
#Refer to elements of a vector using subscripts.
print(y[1:2])
m <- matrix(c(1,2,3,3,2,1),nrow=3,ncol=2)
print(m)
## Define the matrix
m <- matrix(c(1,2,3,3,2,1),nrow=3,ncol=2)
print(m)
## Define the matrix
m <- matrix(c(1,2,3,3,2,1),nrow=3,ncol=2)
print(m)
## Refer to elements of a matrix:
m[,1]
## Define the matrix
m <- matrix(c(1,2,3,3,2,1),nrow=3,ncol=2)
print(m)
## Refer to elements of a matrix:
m[,1]
m[2,]
n<-c(2,3,5)
s<-c('aa','bb','cc')
b<-c(TRUE,FALSE,TRUE)
df=data.frame(n,s,b)
setwd("~/work/Geog4254-5254G/week2")
setwd("~/work/Geog4254-5254G/week1")
list.files()
list.files()
setwd("~/work/Geog4254-5254G/week1")
list.files()
setwd("~/work/Geog4254-5254G/week2")
knitr::opts_chunk$set(echo = FALSE)
library(sf)
pophu <- st_read('y2010.shp')
class(pophu)
plot(pophu["POP10"])
library(mapview)
library(mapveiw)
install.packages('mapview')
install.packages("mapview")
mapview(pophu,z='POP10')
plot(pophu["area"])
pophu$area <- as.numeric(st_area(pophu))
head(pophu)
plot(pophu["area"])
st_write(pophu,'test1.shp')
a<-pophu[pophu$POP10>1000,]
plot(a)
a<-pophu[pophu$POP10>1000,]
plot(a["POP10"])
county<-st_read('mycounty.shp')
pophu_withincounty<-st_intersection(pophu_p,county)
county<-st_read('mycounty.shp')
pophu_withincounty<-st_intersection(pophu,county)
county<-st_read('mycounty.shp')
county_proj<-st_transform(county,crs(pophu))
pophu_withincounty<-st_intersection(pophu,county_proj)
county<-st_read('mycounty.shp')
county_proj<-st_transform(county,crs(pophu))
pophu_withincounty<-st_intersection(pophu,county_proj)
plot(pophu_withincounty)
county<-st_read('mycounty.shp')
county_proj<-st_transform(county,crs(pophu))
pophu_withincounty<-st_intersection(pophu,county_proj)
plot(pophu_withincounty["POP10"])
